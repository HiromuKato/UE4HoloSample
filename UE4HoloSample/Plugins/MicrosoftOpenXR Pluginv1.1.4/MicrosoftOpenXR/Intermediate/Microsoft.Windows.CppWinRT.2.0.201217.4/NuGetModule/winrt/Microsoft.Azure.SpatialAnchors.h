// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.201217.4

#ifndef WINRT_Microsoft_Azure_SpatialAnchors_H
#define WINRT_Microsoft_Azure_SpatialAnchors_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.201217.4"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.201217.4"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Perception.Spatial.2.h"
#include "winrt/impl/Microsoft.Azure.SpatialAnchors.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::BypassCache() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_BypassCache(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::BypassCache(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_BypassCache(value));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::AnchorDataCategory) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::RequestedCategories() const
    {
        Microsoft::Azure::SpatialAnchors::AnchorDataCategory value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_RequestedCategories(reinterpret_cast<uint32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::RequestedCategories(Microsoft::Azure::SpatialAnchors::AnchorDataCategory const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_RequestedCategories(static_cast<uint32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::LocateStrategy) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Strategy() const
    {
        Microsoft::Azure::SpatialAnchors::LocateStrategy value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_Strategy(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Strategy(Microsoft::Azure::SpatialAnchors::LocateStrategy const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_Strategy(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(com_array<hstring>) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Identifiers() const
    {
        uint32_t value_impl_size{};
        void** value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_Identifiers(&value_impl_size, &value));
        return com_array<hstring>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::Identifiers(array_view<hstring const> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_Identifiers(value.size(), get_abi(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::NearAnchorCriteria) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::NearAnchor() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_NearAnchor(&value));
        return Microsoft::Azure::SpatialAnchors::NearAnchorCriteria{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::NearAnchor(Microsoft::Azure::SpatialAnchors::NearAnchorCriteria const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_NearAnchor(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::NearDeviceCriteria) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::NearDevice() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->get_NearDevice(&value));
        return Microsoft::Azure::SpatialAnchors::NearDeviceCriteria{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocateCriteria<D>::NearDevice(Microsoft::Azure::SpatialAnchors::NearDeviceCriteria const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria)->put_NearDevice(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Anchor() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Anchor(&value));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Identifier() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Identifier(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::LocateAnchorStatus) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Status() const
    {
        Microsoft::Azure::SpatialAnchors::LocateAnchorStatus value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Status(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::LocateStrategy) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Strategy() const
    {
        Microsoft::Azure::SpatialAnchors::LocateStrategy value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Strategy(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher) consume_Microsoft_Azure_SpatialAnchors_IAnchorLocatedEventArgs<D>::Watcher() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs)->get_Watcher(&value));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Perception::Spatial::SpatialAnchor) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::LocalAnchor() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_LocalAnchor(&value));
        return Windows::Perception::Spatial::SpatialAnchor{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::LocalAnchor(Windows::Perception::Spatial::SpatialAnchor const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->put_LocalAnchor(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::DateTime) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::Expiration() const
    {
        Windows::Foundation::DateTime value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_Expiration(put_abi(value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::Expiration(Windows::Foundation::DateTime const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->put_Expiration(impl::bind_in(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::Identifier() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_Identifier(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::Collections::IMap<hstring, hstring>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::AppProperties() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_AppProperties(&value));
        return Windows::Foundation::Collections::IMap<hstring, hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchor<D>::VersionTag() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor)->get_VersionTag(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorMap<D>::Identifier() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorMap)->get_Identifier(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorMap<D>::Name() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorMap)->get_Name(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::SessionConfiguration) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Configuration() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_Configuration(&value));
        return Microsoft::Azure::SpatialAnchors::SessionConfiguration{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Diagnostics() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_Diagnostics(&value));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::SessionLogLevel) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LogLevel() const
    {
        Microsoft::Azure::SpatialAnchors::SessionLogLevel value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_LogLevel(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->put_LogLevel(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::PlatformLocationProvider) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocationProvider() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_LocationProvider(&value));
        return Microsoft::Azure::SpatialAnchors::PlatformLocationProvider{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocationProvider(Microsoft::Azure::SpatialAnchors::PlatformLocationProvider const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->put_LocationProvider(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->get_SessionId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired(Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_TokenRequired(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired(auto_revoke_t, Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate const& handler) const
    {
        return impl::make_event_revoker<D, TokenRequired_revoker>(this, TokenRequired(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::TokenRequired(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_TokenRequired(impl::bind_in(token)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated(Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_AnchorLocated(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated(auto_revoke_t, Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate const& handler) const
    {
        return impl::make_event_revoker<D, AnchorLocated_revoker>(this, AnchorLocated(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::AnchorLocated(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_AnchorLocated(impl::bind_in(token)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted(Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_LocateAnchorsCompleted(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted(auto_revoke_t, Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate const& handler) const
    {
        return impl::make_event_revoker<D, LocateAnchorsCompleted_revoker>(this, LocateAnchorsCompleted(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::LocateAnchorsCompleted(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_LocateAnchorsCompleted(impl::bind_in(token)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated(Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_SessionUpdated(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated(auto_revoke_t, Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate const& handler) const
    {
        return impl::make_event_revoker<D, SessionUpdated_revoker>(this, SessionUpdated(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::SessionUpdated(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_SessionUpdated(impl::bind_in(token)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error(Microsoft::Azure::SpatialAnchors::SessionErrorDelegate const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_Error(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error(auto_revoke_t, Microsoft::Azure::SpatialAnchors::SessionErrorDelegate const& handler) const
    {
        return impl::make_event_revoker<D, Error_revoker>(this, Error(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Error(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_Error(impl::bind_in(token)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug(Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_OnLogDebug(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug(auto_revoke_t, Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate const& handler) const
    {
        return impl::make_event_revoker<D, OnLogDebug_revoker>(this, OnLogDebug(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::OnLogDebug(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_OnLogDebug(impl::bind_in(token)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::UpdatedSensorFingerprintRequired(Microsoft::Azure::SpatialAnchors::UpdatedSensorFingerprintRequiredDelegate const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->add_UpdatedSensorFingerprintRequired(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::UpdatedSensorFingerprintRequired_revoker consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::UpdatedSensorFingerprintRequired(auto_revoke_t, Microsoft::Azure::SpatialAnchors::UpdatedSensorFingerprintRequiredDelegate const& handler) const
    {
        return impl::make_event_revoker<D, UpdatedSensorFingerprintRequired_revoker>(this, UpdatedSensorFingerprintRequired(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::UpdatedSensorFingerprintRequired(winrt::event_token const& token) const noexcept
    {
        WINRT_VERIFY_(0, WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->remove_UpdatedSensorFingerprintRequired(impl::bind_in(token)));
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncOperation<hstring>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetAccessTokenWithAuthenticationTokenAsync(param::hstring const& authenticationToken) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetAccessTokenWithAuthenticationTokenAsync(*(void**)(&authenticationToken), &operation));
        return Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncOperation<hstring>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetAccessTokenWithAccountKeyAsync(param::hstring const& accountKey) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetAccessTokenWithAccountKeyAsync(*(void**)(&accountKey), &operation));
        return Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncAction) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::CreateAnchorAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->CreateAnchorAsync(*(void**)(&anchor), &operation));
        return Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::CreateWatcher(Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria const& criteria) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->CreateWatcher(*(void**)(&criteria), &result));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetAnchorPropertiesAsync(param::hstring const& identifier) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetAnchorPropertiesAsync(*(void**)(&identifier), &operation));
        return Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncOperation<Windows::Foundation::Collections::IVector<hstring>>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetNearbyAnchorIdsAsync(Microsoft::Azure::SpatialAnchors::NearDeviceCriteria const& criteria) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetNearbyAnchorIdsAsync(*(void**)(&criteria), &operation));
        return Windows::Foundation::IAsyncOperation<Windows::Foundation::Collections::IVector<hstring>>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::Collections::IVectorView<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetActiveWatchers() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetActiveWatchers(&result));
        return Windows::Foundation::Collections::IVectorView<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncAction) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::RefreshAnchorPropertiesAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->RefreshAnchorPropertiesAsync(*(void**)(&anchor), &operation));
        return Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncAction) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::UpdateAnchorPropertiesAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->UpdateAnchorPropertiesAsync(*(void**)(&anchor), &operation));
        return Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncAction) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::DeleteAnchorAsync(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& anchor) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->DeleteAnchorAsync(*(void**)(&anchor), &operation));
        return Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::SessionStatus>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::GetSessionStatusAsync() const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->GetSessionStatusAsync(&operation));
        return Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::SessionStatus>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Start() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Start());
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Stop() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Stop());
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Reset() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Reset());
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSession<D>::Dispose() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession)->Dispose());
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDeferral<D>::Complete() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral)->Complete());
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::SessionLogLevel) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogLevel() const
    {
        Microsoft::Azure::SpatialAnchors::SessionLogLevel value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_LogLevel(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogLevel(Microsoft::Azure::SpatialAnchors::SessionLogLevel const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_LogLevel(static_cast<int32_t>(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogDirectory() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_LogDirectory(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::LogDirectory(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_LogDirectory(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(int32_t) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::MaxDiskSizeInMB() const
    {
        int32_t value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_MaxDiskSizeInMB(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::MaxDiskSizeInMB(int32_t value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_MaxDiskSizeInMB(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::ImagesEnabled() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->get_ImagesEnabled(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::ImagesEnabled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->put_ImagesEnabled(value));
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncOperation<hstring>) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::CreateManifestAsync(param::hstring const& description) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->CreateManifestAsync(*(void**)(&description), &operation));
        return Windows::Foundation::IAsyncOperation<hstring>{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Windows::Foundation::IAsyncAction) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorSessionDiagnostics<D>::SubmitManifestAsync(param::hstring const& manifestPath) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics)->SubmitManifestAsync(*(void**)(&manifestPath), &operation));
        return Windows::Foundation::IAsyncAction{ operation, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(int32_t) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorWatcher<D>::Identifier() const
    {
        int32_t value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher)->get_Identifier(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ICloudSpatialAnchorWatcher<D>::Stop() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher)->Stop());
    }
    template <typename D> WINRT_IMPL_AUTO(double) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::Latitude() const
    {
        double value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->get_Latitude(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::Latitude(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->put_Latitude(value));
    }
    template <typename D> WINRT_IMPL_AUTO(double) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::Longitude() const
    {
        double value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->get_Longitude(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::Longitude(double value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->put_Longitude(value));
    }
    template <typename D> WINRT_IMPL_AUTO(float) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::HorizontalError() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->get_HorizontalError(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::HorizontalError(float value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->put_HorizontalError(value));
    }
    template <typename D> WINRT_IMPL_AUTO(float) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::Altitude() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->get_Altitude(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::Altitude(float value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->put_Altitude(value));
    }
    template <typename D> WINRT_IMPL_AUTO(float) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::VerticalError() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->get_VerticalError(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IGeoLocation<D>::VerticalError(float value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IGeoLocation)->put_VerticalError(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Azure_SpatialAnchors_ILocateAnchorsCompletedEventArgs<D>::Cancelled() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs)->get_Cancelled(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher) consume_Microsoft_Azure_SpatialAnchors_ILocateAnchorsCompletedEventArgs<D>::Watcher() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs)->get_Watcher(&value));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor) consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::SourceAnchor() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->get_SourceAnchor(&value));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::SourceAnchor(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->put_SourceAnchor(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(float) consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::DistanceInMeters() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->get_DistanceInMeters(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::DistanceInMeters(float value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->put_DistanceInMeters(value));
    }
    template <typename D> WINRT_IMPL_AUTO(int32_t) consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::MaxResultCount() const
    {
        int32_t value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->get_MaxResultCount(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_INearAnchorCriteria<D>::MaxResultCount(int32_t value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearAnchorCriteria)->put_MaxResultCount(value));
    }
    template <typename D> WINRT_IMPL_AUTO(float) consume_Microsoft_Azure_SpatialAnchors_INearDeviceCriteria<D>::DistanceInMeters() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearDeviceCriteria)->get_DistanceInMeters(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_INearDeviceCriteria<D>::DistanceInMeters(float value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearDeviceCriteria)->put_DistanceInMeters(value));
    }
    template <typename D> WINRT_IMPL_AUTO(int32_t) consume_Microsoft_Azure_SpatialAnchors_INearDeviceCriteria<D>::MaxResultCount() const
    {
        int32_t value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearDeviceCriteria)->get_MaxResultCount(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_INearDeviceCriteria<D>::MaxResultCount(int32_t value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::INearDeviceCriteria)->put_MaxResultCount(value));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_IOnLogDebugEventArgs<D>::Message() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs)->get_Message(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::SensorCapabilities) consume_Microsoft_Azure_SpatialAnchors_IPlatformLocationProvider<D>::Sensors() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider)->get_Sensors(&value));
        return Microsoft::Azure::SpatialAnchors::SensorCapabilities{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::GeoLocationStatusResult) consume_Microsoft_Azure_SpatialAnchors_IPlatformLocationProvider<D>::GeoLocationStatus() const
    {
        Microsoft::Azure::SpatialAnchors::GeoLocationStatusResult value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider)->get_GeoLocationStatus(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::WifiStatusResult) consume_Microsoft_Azure_SpatialAnchors_IPlatformLocationProvider<D>::WifiStatus() const
    {
        Microsoft::Azure::SpatialAnchors::WifiStatusResult value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider)->get_WifiStatus(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::BluetoothStatusResult) consume_Microsoft_Azure_SpatialAnchors_IPlatformLocationProvider<D>::BluetoothStatus() const
    {
        Microsoft::Azure::SpatialAnchors::BluetoothStatusResult value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider)->get_BluetoothStatus(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::GeoLocation) consume_Microsoft_Azure_SpatialAnchors_IPlatformLocationProvider<D>::GetLocationEstimate() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider)->GetLocationEstimate(&result));
        return Microsoft::Azure::SpatialAnchors::GeoLocation{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IPlatformLocationProvider<D>::Start() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider)->Start());
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_IPlatformLocationProvider<D>::Stop() const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider)->Stop());
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::GeoLocationEnabled() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->get_GeoLocationEnabled(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::GeoLocationEnabled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->put_GeoLocationEnabled(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::WifiEnabled() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->get_WifiEnabled(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::WifiEnabled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->put_WifiEnabled(value));
    }
    template <typename D> WINRT_IMPL_AUTO(bool) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::BluetoothEnabled() const
    {
        bool value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->get_BluetoothEnabled(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::BluetoothEnabled(bool value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->put_BluetoothEnabled(value));
    }
    template <typename D> WINRT_IMPL_AUTO(com_array<hstring>) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::KnownBeaconProximityUuids() const
    {
        uint32_t value_impl_size{};
        void** value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->get_KnownBeaconProximityUuids(&value_impl_size, &value));
        return com_array<hstring>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISensorCapabilities<D>::KnownBeaconProximityUuids(array_view<hstring const> value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorCapabilities)->put_KnownBeaconProximityUuids(value.size(), get_abi(value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::GeoLocation) consume_Microsoft_Azure_SpatialAnchors_ISensorFingerprintEventArgs<D>::GeoPosition() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorFingerprintEventArgs)->get_GeoPosition(&value));
        return Microsoft::Azure::SpatialAnchors::GeoLocation{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISensorFingerprintEventArgs<D>::GeoPosition(Microsoft::Azure::SpatialAnchors::GeoLocation const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISensorFingerprintEventArgs)->put_GeoPosition(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountDomain() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccountDomain(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountDomain(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccountDomain(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountId() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccountId(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountId(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccountId(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AuthenticationToken() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AuthenticationToken(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AuthenticationToken(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AuthenticationToken(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountKey() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccountKey(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccountKey(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccountKey(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccessToken() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->get_AccessToken(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ISessionConfiguration<D>::AccessToken(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionConfiguration)->put_AccessToken(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode) consume_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs<D>::ErrorCode() const
    {
        Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs)->get_ErrorCode(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs<D>::ErrorMessage() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs)->get_ErrorMessage(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher) consume_Microsoft_Azure_SpatialAnchors_ISessionErrorEventArgs<D>::Watcher() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs)->get_Watcher(&value));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(float) consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::ReadyForCreateProgress() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_ReadyForCreateProgress(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(float) consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::RecommendedForCreateProgress() const
    {
        float value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_RecommendedForCreateProgress(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(int32_t) consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::SessionCreateHash() const
    {
        int32_t value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_SessionCreateHash(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(int32_t) consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::SessionLocateHash() const
    {
        int32_t value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_SessionLocateHash(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::SessionUserFeedback) consume_Microsoft_Azure_SpatialAnchors_ISessionStatus<D>::UserFeedback() const
    {
        Microsoft::Azure::SpatialAnchors::SessionUserFeedback value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionStatus)->get_UserFeedback(reinterpret_cast<uint32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::SessionStatus) consume_Microsoft_Azure_SpatialAnchors_ISessionUpdatedEventArgs<D>::Status() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs)->get_Status(&value));
        return Microsoft::Azure::SpatialAnchors::SessionStatus{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AccessToken() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->get_AccessToken(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AccessToken(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->put_AccessToken(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AuthenticationToken() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->get_AuthenticationToken(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::AuthenticationToken(param::hstring const& value) const
    {
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->put_AuthenticationToken(*(void**)(&value)));
    }
    template <typename D> WINRT_IMPL_AUTO(Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral) consume_Microsoft_Azure_SpatialAnchors_ITokenRequiredEventArgs<D>::GetDeferral() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs)->GetDeferral(&result));
        return Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral{ result, take_ownership_from_abi };
    }
    template <typename H> struct delegate<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate, H> final : implements_delegate<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate, H>
    {
        delegate(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate, H> final : implements_delegate<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate, H>
    {
        delegate(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate, H> final : implements_delegate<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate, H>
    {
        delegate(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate, H> final : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate, H>
    {
        delegate(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate, H> final : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate, H>
    {
        delegate(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate, H> final : implements_delegate<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate, H>
    {
        delegate(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename H> struct delegate<Microsoft::Azure::SpatialAnchors::UpdatedSensorFingerprintRequiredDelegate, H> final : implements_delegate<Microsoft::Azure::SpatialAnchors::UpdatedSensorFingerprintRequiredDelegate, H>
    {
        delegate(H&& handler) : implements_delegate<Microsoft::Azure::SpatialAnchors::UpdatedSensorFingerprintRequiredDelegate, H>(std::forward<H>(handler)) {}

        int32_t __stdcall Invoke(void* sender, void* args) noexcept final try
        {
            (*this)(*reinterpret_cast<Windows::Foundation::IInspectable const*>(&sender), *reinterpret_cast<Microsoft::Azure::SpatialAnchors::SensorFingerprintEventArgs const*>(&args));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria> : produce_base<D, Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria>
    {
        int32_t __stdcall get_BypassCache(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().BypassCache());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BypassCache(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BypassCache(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RequestedCategories(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::AnchorDataCategory>(this->shim().RequestedCategories());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_RequestedCategories(uint32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().RequestedCategories(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorDataCategory const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Strategy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::LocateStrategy>(this->shim().Strategy());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Strategy(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Strategy(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::LocateStrategy const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Identifiers(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().Identifiers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Identifiers(uint32_t __valueSize, void** value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Identifiers(array_view<hstring const>(reinterpret_cast<hstring const *>(value), reinterpret_cast<hstring const *>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NearAnchor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::NearAnchorCriteria>(this->shim().NearAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NearAnchor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NearAnchor(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::NearAnchorCriteria const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_NearDevice(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::NearDeviceCriteria>(this->shim().NearDevice());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_NearDevice(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().NearDevice(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::NearDeviceCriteria const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs>
    {
        int32_t __stdcall get_Anchor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>(this->shim().Anchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Identifier(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Identifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Status(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::LocateAnchorStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Strategy(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::LocateStrategy>(this->shim().Strategy());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Watcher(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().Watcher());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor>
    {
        int32_t __stdcall get_LocalAnchor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Perception::Spatial::SpatialAnchor>(this->shim().LocalAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LocalAnchor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LocalAnchor(*reinterpret_cast<Windows::Perception::Spatial::SpatialAnchor const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Expiration(int64_t* value) noexcept final try
        {
            zero_abi<Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::DateTime>(this->shim().Expiration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Expiration(int64_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Expiration(*reinterpret_cast<Windows::Foundation::DateTime const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Identifier(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Identifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AppProperties(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Collections::IMap<hstring, hstring>>(this->shim().AppProperties());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VersionTag(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().VersionTag());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorMap> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorMap>
    {
        int32_t __stdcall get_Identifier(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Identifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession>
    {
        int32_t __stdcall get_Configuration(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionConfiguration>(this->shim().Configuration());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Diagnostics(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics>(this->shim().Diagnostics());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LogLevel(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionLogLevel>(this->shim().LogLevel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LogLevel(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LogLevel(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionLogLevel const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LocationProvider(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::PlatformLocationProvider>(this->shim().LocationProvider());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LocationProvider(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LocationProvider(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::PlatformLocationProvider const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SessionId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().SessionId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_TokenRequired(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().TokenRequired(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::TokenRequiredDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_TokenRequired(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TokenRequired(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_AnchorLocated(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().AnchorLocated(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorLocatedDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_AnchorLocated(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AnchorLocated(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_LocateAnchorsCompleted(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().LocateAnchorsCompleted(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_LocateAnchorsCompleted(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LocateAnchorsCompleted(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_SessionUpdated(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().SessionUpdated(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionUpdatedDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_SessionUpdated(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SessionUpdated(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_Error(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().Error(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionErrorDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_Error(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Error(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_OnLogDebug(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().OnLogDebug(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::OnLogDebugDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_OnLogDebug(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().OnLogDebug(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall add_UpdatedSensorFingerprintRequired(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().UpdatedSensorFingerprintRequired(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::UpdatedSensorFingerprintRequiredDelegate const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_UpdatedSensorFingerprintRequired(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().UpdatedSensorFingerprintRequired(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
        int32_t __stdcall GetAccessTokenWithAuthenticationTokenAsync(void* authenticationToken, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().GetAccessTokenWithAuthenticationTokenAsync(*reinterpret_cast<hstring const*>(&authenticationToken)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetAccessTokenWithAccountKeyAsync(void* accountKey, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().GetAccessTokenWithAccountKeyAsync(*reinterpret_cast<hstring const*>(&accountKey)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateAnchorAsync(void* anchor, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().CreateAnchorAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateWatcher(void* criteria, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().CreateWatcher(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria const*>(&criteria)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetAnchorPropertiesAsync(void* identifier, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>>(this->shim().GetAnchorPropertiesAsync(*reinterpret_cast<hstring const*>(&identifier)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetNearbyAnchorIdsAsync(void* criteria, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<Windows::Foundation::Collections::IVector<hstring>>>(this->shim().GetNearbyAnchorIdsAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::NearDeviceCriteria const*>(&criteria)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetActiveWatchers(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Windows::Foundation::Collections::IVectorView<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>>(this->shim().GetActiveWatchers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RefreshAnchorPropertiesAsync(void* anchor, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().RefreshAnchorPropertiesAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall UpdateAnchorPropertiesAsync(void* anchor, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().UpdateAnchorPropertiesAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DeleteAnchorAsync(void* anchor, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().DeleteAnchorAsync(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&anchor)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSessionStatusAsync(void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<Microsoft::Azure::SpatialAnchors::SessionStatus>>(this->shim().GetSessionStatusAsync());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Start() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Start();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Stop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Reset() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Reset();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Dispose() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Dispose();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral>
    {
        int32_t __stdcall Complete() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Complete();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics>
    {
        int32_t __stdcall get_LogLevel(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionLogLevel>(this->shim().LogLevel());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LogLevel(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LogLevel(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::SessionLogLevel const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LogDirectory(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().LogDirectory());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_LogDirectory(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().LogDirectory(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxDiskSizeInMB(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxDiskSizeInMB());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxDiskSizeInMB(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxDiskSizeInMB(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ImagesEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().ImagesEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_ImagesEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ImagesEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateManifestAsync(void* description, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<hstring>>(this->shim().CreateManifestAsync(*reinterpret_cast<hstring const*>(&description)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SubmitManifestAsync(void* manifestPath, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncAction>(this->shim().SubmitManifestAsync(*reinterpret_cast<hstring const*>(&manifestPath)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher> : produce_base<D, Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher>
    {
        int32_t __stdcall get_Identifier(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().Identifier());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Stop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::IGeoLocation> : produce_base<D, Microsoft::Azure::SpatialAnchors::IGeoLocation>
    {
        int32_t __stdcall get_Latitude(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Latitude());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Latitude(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Latitude(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Longitude(double* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<double>(this->shim().Longitude());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Longitude(double value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Longitude(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HorizontalError(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().HorizontalError());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_HorizontalError(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().HorizontalError(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Altitude(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().Altitude());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_Altitude(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Altitude(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_VerticalError(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().VerticalError());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_VerticalError(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().VerticalError(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs>
    {
        int32_t __stdcall get_Cancelled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().Cancelled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Watcher(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().Watcher());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::INearAnchorCriteria> : produce_base<D, Microsoft::Azure::SpatialAnchors::INearAnchorCriteria>
    {
        int32_t __stdcall get_SourceAnchor(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor>(this->shim().SourceAnchor());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_SourceAnchor(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SourceAnchor(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DistanceInMeters(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().DistanceInMeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DistanceInMeters(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DistanceInMeters(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxResultCount(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxResultCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxResultCount(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxResultCount(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::INearDeviceCriteria> : produce_base<D, Microsoft::Azure::SpatialAnchors::INearDeviceCriteria>
    {
        int32_t __stdcall get_DistanceInMeters(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().DistanceInMeters());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_DistanceInMeters(float value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().DistanceInMeters(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_MaxResultCount(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().MaxResultCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_MaxResultCount(int32_t value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().MaxResultCount(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs>
    {
        int32_t __stdcall get_Message(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Message());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider> : produce_base<D, Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider>
    {
        int32_t __stdcall get_Sensors(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SensorCapabilities>(this->shim().Sensors());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_GeoLocationStatus(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::GeoLocationStatusResult>(this->shim().GeoLocationStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WifiStatus(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::WifiStatusResult>(this->shim().WifiStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BluetoothStatus(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::BluetoothStatusResult>(this->shim().BluetoothStatus());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetLocationEstimate(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Microsoft::Azure::SpatialAnchors::GeoLocation>(this->shim().GetLocationEstimate());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Start() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Start();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Stop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Stop();
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ISensorCapabilities> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISensorCapabilities>
    {
        int32_t __stdcall get_GeoLocationEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().GeoLocationEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_GeoLocationEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GeoLocationEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_WifiEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().WifiEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_WifiEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().WifiEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_BluetoothEnabled(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().BluetoothEnabled());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_BluetoothEnabled(bool value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().BluetoothEnabled(value);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_KnownBeaconProximityUuids(uint32_t* __valueSize, void*** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().KnownBeaconProximityUuids());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_KnownBeaconProximityUuids(uint32_t __valueSize, void** value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().KnownBeaconProximityUuids(array_view<hstring const>(reinterpret_cast<hstring const *>(value), reinterpret_cast<hstring const *>(value) + __valueSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ISensorFingerprintEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISensorFingerprintEventArgs>
    {
        int32_t __stdcall get_GeoPosition(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::GeoLocation>(this->shim().GeoPosition());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_GeoPosition(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().GeoPosition(*reinterpret_cast<Microsoft::Azure::SpatialAnchors::GeoLocation const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionConfiguration> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionConfiguration>
    {
        int32_t __stdcall get_AccountDomain(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AccountDomain());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AccountDomain(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AccountDomain(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AccountId(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AccountId());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AccountId(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AccountId(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AuthenticationToken(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AuthenticationToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AuthenticationToken(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AuthenticationToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AccountKey(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AccountKey());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AccountKey(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AccountKey(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AccessToken(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AccessToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AccessToken(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AccessToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs>
    {
        int32_t __stdcall get_ErrorCode(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialErrorCode>(this->shim().ErrorCode());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ErrorMessage(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ErrorMessage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Watcher(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher>(this->shim().Watcher());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionStatus> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionStatus>
    {
        int32_t __stdcall get_ReadyForCreateProgress(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().ReadyForCreateProgress());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_RecommendedForCreateProgress(float* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<float>(this->shim().RecommendedForCreateProgress());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SessionCreateHash(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().SessionCreateHash());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_SessionLocateHash(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().SessionLocateHash());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_UserFeedback(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionUserFeedback>(this->shim().UserFeedback());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs>
    {
        int32_t __stdcall get_Status(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Microsoft::Azure::SpatialAnchors::SessionStatus>(this->shim().Status());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs> : produce_base<D, Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs>
    {
        int32_t __stdcall get_AccessToken(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AccessToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AccessToken(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AccessToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_AuthenticationToken(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().AuthenticationToken());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall put_AuthenticationToken(void* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().AuthenticationToken(*reinterpret_cast<hstring const*>(&value));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetDeferral(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral>(this->shim().GetDeferral());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Azure::SpatialAnchors
{
    constexpr auto operator|(AnchorDataCategory const left, AnchorDataCategory const right) noexcept
    {
        return static_cast<AnchorDataCategory>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(AnchorDataCategory& left, AnchorDataCategory const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(AnchorDataCategory const left, AnchorDataCategory const right) noexcept
    {
        return static_cast<AnchorDataCategory>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(AnchorDataCategory& left, AnchorDataCategory const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(AnchorDataCategory const value) noexcept
    {
        return static_cast<AnchorDataCategory>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(AnchorDataCategory const left, AnchorDataCategory const right) noexcept
    {
        return static_cast<AnchorDataCategory>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(AnchorDataCategory& left, AnchorDataCategory const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    constexpr auto operator|(SessionUserFeedback const left, SessionUserFeedback const right) noexcept
    {
        return static_cast<SessionUserFeedback>(impl::to_underlying_type(left) | impl::to_underlying_type(right));
    }
    constexpr auto operator|=(SessionUserFeedback& left, SessionUserFeedback const right) noexcept
    {
        left = left | right;
        return left;
    }
    constexpr auto operator&(SessionUserFeedback const left, SessionUserFeedback const right) noexcept
    {
        return static_cast<SessionUserFeedback>(impl::to_underlying_type(left) & impl::to_underlying_type(right));
    }
    constexpr auto operator&=(SessionUserFeedback& left, SessionUserFeedback const right) noexcept
    {
        left = left & right;
        return left;
    }
    constexpr auto operator~(SessionUserFeedback const value) noexcept
    {
        return static_cast<SessionUserFeedback>(~impl::to_underlying_type(value));
    }
    constexpr auto operator^(SessionUserFeedback const left, SessionUserFeedback const right) noexcept
    {
        return static_cast<SessionUserFeedback>(impl::to_underlying_type(left) ^ impl::to_underlying_type(right));
    }
    constexpr auto operator^=(SessionUserFeedback& left, SessionUserFeedback const right) noexcept
    {
        left = left ^ right;
        return left;
    }
    inline AnchorLocateCriteria::AnchorLocateCriteria() :
        AnchorLocateCriteria(impl::call_factory_cast<AnchorLocateCriteria(*)(Windows::Foundation::IActivationFactory const&), AnchorLocateCriteria>([](Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<AnchorLocateCriteria>(); }))
    {
    }
    inline CloudSpatialAnchor::CloudSpatialAnchor() :
        CloudSpatialAnchor(impl::call_factory_cast<CloudSpatialAnchor(*)(Windows::Foundation::IActivationFactory const&), CloudSpatialAnchor>([](Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<CloudSpatialAnchor>(); }))
    {
    }
    inline CloudSpatialAnchorSession::CloudSpatialAnchorSession() :
        CloudSpatialAnchorSession(impl::call_factory_cast<CloudSpatialAnchorSession(*)(Windows::Foundation::IActivationFactory const&), CloudSpatialAnchorSession>([](Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<CloudSpatialAnchorSession>(); }))
    {
    }
    inline GeoLocation::GeoLocation() :
        GeoLocation(impl::call_factory_cast<GeoLocation(*)(Windows::Foundation::IActivationFactory const&), GeoLocation>([](Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<GeoLocation>(); }))
    {
    }
    inline NearAnchorCriteria::NearAnchorCriteria() :
        NearAnchorCriteria(impl::call_factory_cast<NearAnchorCriteria(*)(Windows::Foundation::IActivationFactory const&), NearAnchorCriteria>([](Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<NearAnchorCriteria>(); }))
    {
    }
    inline NearDeviceCriteria::NearDeviceCriteria() :
        NearDeviceCriteria(impl::call_factory_cast<NearDeviceCriteria(*)(Windows::Foundation::IActivationFactory const&), NearDeviceCriteria>([](Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<NearDeviceCriteria>(); }))
    {
    }
    inline PlatformLocationProvider::PlatformLocationProvider() :
        PlatformLocationProvider(impl::call_factory_cast<PlatformLocationProvider(*)(Windows::Foundation::IActivationFactory const&), PlatformLocationProvider>([](Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<PlatformLocationProvider>(); }))
    {
    }
    template <typename L> AnchorLocatedDelegate::AnchorLocatedDelegate(L handler) :
        AnchorLocatedDelegate(impl::make_delegate<AnchorLocatedDelegate>(std::forward<L>(handler)))
    {
    }
    template <typename F> AnchorLocatedDelegate::AnchorLocatedDelegate(F* handler) :
        AnchorLocatedDelegate([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> AnchorLocatedDelegate::AnchorLocatedDelegate(O* object, M method) :
        AnchorLocatedDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> AnchorLocatedDelegate::AnchorLocatedDelegate(com_ptr<O>&& object, M method) :
        AnchorLocatedDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> AnchorLocatedDelegate::AnchorLocatedDelegate(weak_ref<O>&& object, M method) :
        AnchorLocatedDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto AnchorLocatedDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs const& args) const
    {
        check_hresult((*(impl::abi_t<AnchorLocatedDelegate>**)this)->Invoke(*(void**)(&sender), *(void**)(&args)));
    }
    template <typename L> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(L handler) :
        LocateAnchorsCompletedDelegate(impl::make_delegate<LocateAnchorsCompletedDelegate>(std::forward<L>(handler)))
    {
    }
    template <typename F> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(F* handler) :
        LocateAnchorsCompletedDelegate([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(O* object, M method) :
        LocateAnchorsCompletedDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(com_ptr<O>&& object, M method) :
        LocateAnchorsCompletedDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> LocateAnchorsCompletedDelegate::LocateAnchorsCompletedDelegate(weak_ref<O>&& object, M method) :
        LocateAnchorsCompletedDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto LocateAnchorsCompletedDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs const& args) const
    {
        check_hresult((*(impl::abi_t<LocateAnchorsCompletedDelegate>**)this)->Invoke(*(void**)(&sender), *(void**)(&args)));
    }
    template <typename L> OnLogDebugDelegate::OnLogDebugDelegate(L handler) :
        OnLogDebugDelegate(impl::make_delegate<OnLogDebugDelegate>(std::forward<L>(handler)))
    {
    }
    template <typename F> OnLogDebugDelegate::OnLogDebugDelegate(F* handler) :
        OnLogDebugDelegate([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> OnLogDebugDelegate::OnLogDebugDelegate(O* object, M method) :
        OnLogDebugDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> OnLogDebugDelegate::OnLogDebugDelegate(com_ptr<O>&& object, M method) :
        OnLogDebugDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> OnLogDebugDelegate::OnLogDebugDelegate(weak_ref<O>&& object, M method) :
        OnLogDebugDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto OnLogDebugDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs const& args) const
    {
        check_hresult((*(impl::abi_t<OnLogDebugDelegate>**)this)->Invoke(*(void**)(&sender), *(void**)(&args)));
    }
    template <typename L> SessionErrorDelegate::SessionErrorDelegate(L handler) :
        SessionErrorDelegate(impl::make_delegate<SessionErrorDelegate>(std::forward<L>(handler)))
    {
    }
    template <typename F> SessionErrorDelegate::SessionErrorDelegate(F* handler) :
        SessionErrorDelegate([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> SessionErrorDelegate::SessionErrorDelegate(O* object, M method) :
        SessionErrorDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> SessionErrorDelegate::SessionErrorDelegate(com_ptr<O>&& object, M method) :
        SessionErrorDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> SessionErrorDelegate::SessionErrorDelegate(weak_ref<O>&& object, M method) :
        SessionErrorDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto SessionErrorDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs const& args) const
    {
        check_hresult((*(impl::abi_t<SessionErrorDelegate>**)this)->Invoke(*(void**)(&sender), *(void**)(&args)));
    }
    template <typename L> SessionUpdatedDelegate::SessionUpdatedDelegate(L handler) :
        SessionUpdatedDelegate(impl::make_delegate<SessionUpdatedDelegate>(std::forward<L>(handler)))
    {
    }
    template <typename F> SessionUpdatedDelegate::SessionUpdatedDelegate(F* handler) :
        SessionUpdatedDelegate([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> SessionUpdatedDelegate::SessionUpdatedDelegate(O* object, M method) :
        SessionUpdatedDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> SessionUpdatedDelegate::SessionUpdatedDelegate(com_ptr<O>&& object, M method) :
        SessionUpdatedDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> SessionUpdatedDelegate::SessionUpdatedDelegate(weak_ref<O>&& object, M method) :
        SessionUpdatedDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto SessionUpdatedDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs const& args) const
    {
        check_hresult((*(impl::abi_t<SessionUpdatedDelegate>**)this)->Invoke(*(void**)(&sender), *(void**)(&args)));
    }
    template <typename L> TokenRequiredDelegate::TokenRequiredDelegate(L handler) :
        TokenRequiredDelegate(impl::make_delegate<TokenRequiredDelegate>(std::forward<L>(handler)))
    {
    }
    template <typename F> TokenRequiredDelegate::TokenRequiredDelegate(F* handler) :
        TokenRequiredDelegate([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> TokenRequiredDelegate::TokenRequiredDelegate(O* object, M method) :
        TokenRequiredDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> TokenRequiredDelegate::TokenRequiredDelegate(com_ptr<O>&& object, M method) :
        TokenRequiredDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> TokenRequiredDelegate::TokenRequiredDelegate(weak_ref<O>&& object, M method) :
        TokenRequiredDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto TokenRequiredDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs const& args) const
    {
        check_hresult((*(impl::abi_t<TokenRequiredDelegate>**)this)->Invoke(*(void**)(&sender), *(void**)(&args)));
    }
    template <typename L> UpdatedSensorFingerprintRequiredDelegate::UpdatedSensorFingerprintRequiredDelegate(L handler) :
        UpdatedSensorFingerprintRequiredDelegate(impl::make_delegate<UpdatedSensorFingerprintRequiredDelegate>(std::forward<L>(handler)))
    {
    }
    template <typename F> UpdatedSensorFingerprintRequiredDelegate::UpdatedSensorFingerprintRequiredDelegate(F* handler) :
        UpdatedSensorFingerprintRequiredDelegate([=](auto&&... args) { return handler(args...); })
    {
    }
    template <typename O, typename M> UpdatedSensorFingerprintRequiredDelegate::UpdatedSensorFingerprintRequiredDelegate(O* object, M method) :
        UpdatedSensorFingerprintRequiredDelegate([=](auto&&... args) { return ((*object).*(method))(args...); })
    {
    }
    template <typename O, typename M> UpdatedSensorFingerprintRequiredDelegate::UpdatedSensorFingerprintRequiredDelegate(com_ptr<O>&& object, M method) :
        UpdatedSensorFingerprintRequiredDelegate([o = std::move(object), method](auto&&... args) { return ((*o).*(method))(args...); })
    {
    }
    template <typename O, typename M> UpdatedSensorFingerprintRequiredDelegate::UpdatedSensorFingerprintRequiredDelegate(weak_ref<O>&& object, M method) :
        UpdatedSensorFingerprintRequiredDelegate([o = std::move(object), method](auto&&... args) { if (auto s = o.get()) { ((*s).*(method))(args...); } })
    {
    }
    inline auto UpdatedSensorFingerprintRequiredDelegate::operator()(Windows::Foundation::IInspectable const& sender, Microsoft::Azure::SpatialAnchors::SensorFingerprintEventArgs const& args) const
    {
        check_hresult((*(impl::abi_t<UpdatedSensorFingerprintRequiredDelegate>**)this)->Invoke(*(void**)(&sender), *(void**)(&args)));
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocateCriteria> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IAnchorLocatedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorMap> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDeferral> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorSessionDiagnostics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ICloudSpatialAnchorWatcher> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IGeoLocation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ILocateAnchorsCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::INearAnchorCriteria> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::INearDeviceCriteria> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IOnLogDebugEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::IPlatformLocationProvider> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISensorCapabilities> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISensorFingerprintEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionConfiguration> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionErrorEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ISessionUpdatedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::ITokenRequiredEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::AnchorLocateCriteria> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::AnchorLocatedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchor> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorMap> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSession> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDeferral> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorSessionDiagnostics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::CloudSpatialAnchorWatcher> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::GeoLocation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::LocateAnchorsCompletedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::NearAnchorCriteria> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::NearDeviceCriteria> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::OnLogDebugEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::PlatformLocationProvider> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SensorCapabilities> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SensorFingerprintEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionConfiguration> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionErrorEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionStatus> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::SessionUpdatedEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Azure::SpatialAnchors::TokenRequiredEventArgs> : winrt::impl::hash_base {};
#endif
}
#endif
